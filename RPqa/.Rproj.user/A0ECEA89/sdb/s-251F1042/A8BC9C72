{
    "contents" : "RPqamw = function(dist.mat, eps=1, mlen= 2, mw= 0, step=0, theiler= 0, plotG=FALSE){\n    #\n    # version: 10-09-2012\n    #\n    # Moving window version of the analysis\n    # Theiler window is now implemented\n    # Insert some checking\n    stopifnot( is.null(dist.mat) | (class(dist.mat)==\"dist\"), \n               is.null(eps) | (length(eps) == 1 & eps > 0),\n               is.null(mlen) | (length(mlen) == 1 & mlen > 1),\n               is.null(mw) | (length(mw) == 1 & mw >=0 ),\n               is.null(step) | (length(step) == 1 & step >= 0),\n               is.null(theiler) | (length(theiler) == 1 & theiler >= 0),\n               plotG %in% c(\"FALSE\", \"F\", \"T\", \"TRUE\"),\n               theiler = floor(theiler), mw= floor(mw), eps= floor(eps),\n               mlen = floor(mlen), step = floor(step), mw > theiler\n    )\n    # Calculate length\n    n = (1+(1+8*length(dist.mat))^0.5)/2\n    # Calculate series\n    D = as.matrix(dist.mat)\n    # Calculate recurrance matrix\n    D = matrix(as.integer(D <= eps), n, n)\n    # Calculate number of moving windows\n    Nmw= floor(n/mw)\n    if (Nmw == 0) stop(\"Moving window too big!\")\n    RepMW = floor((n -mw)/step)\n    if (RepMW == 0) stop(\"Step too big with this moving window!\")\n    #\n    # Build the container of the results: a matrix\n    #\n    ris = matrix(0, 14, RepMW)\n    rownames(ris) = c(\"recur\", \"diag\", \"vert\", \"prec\", \"det\", \"lam\", \"ratio\", \"meanL\", \"TT\", \"lmax\", \"vmax\", \"DIV\", \"H\", \"Hn\")\n    #\n    # Calculate the values\n    #\n    for (w in 1:RepMW) {\n    # Build amatrix dLV for holding distribution results\n    # We are looking at half of the matrix excluding LOI\n    Dmw = D[(n-mw-w):(n-w+1), (n-mw-w):(n-w+1) ]\n    dLV = matrix(0, 2, mw)\n    # let's calculate dL\n    for (i in (2+theiler):mw) {\n      l =0\n      for (j in 1:(mw-i+1))\n        if (Dmw[(i+j -1), j] == 1) l=l+1 else { \n          dLV[1, 1] = dLV[1, 1] + 1\n          if (l>0) { dLV[1, (l+1)] = dLV[1,(l+1)] + 1\n                     l=0 } \n        }\n      if (l > 0) dLV[1, (l+1)] = dLV[1,(l+1)] + 1\n    }\n    # let's calculate dV going through columns\n    for (j in 1:(mw-theiler-1)) {\n      l =0\n      for (i in (j+1+theiler):mw)\n        if (Dmw[i, j] == 1) l=l+1 else { \n          dLV[2, 1] = dLV[2, 1] + 1\n          if (l>0) { dLV[2, (l+1)] = dLV[2,(l+1)] + 1\n                     l=0 } \n        }\n      if (l > 0) dLV[2, (l+1)] = dLV[2,(l+1)] + 1\n    }\n    #  dLV = dLV * 2 # Because we have used only half of the matrix\n    #  dLV[1, n+1] = dLV[1, n+1]/2\n    dLV = dLV[, -1]\n    dLL = c(1:(mw-1)) #vector for calculation on length\n    # Compute RQA based on Webber!!!\n    ris[1, w] = sum(dLV[1, ] * dLL)\n    ris[2, w] = sum(dLV[1, mlen:(mw-1)])\n    ris[3, w] = sum(dLV[2, mlen:(mw-1)])\n    ris[4, w] = ris[1, w]/((mw^2 -mw)/2)\n    ris[5, w] = sum(dLV[1, mlen:(mw-1)]*dLL[mlen:(mw-1)])/ris[1, w]\n    ris[6, w] = sum(dLV[2, mlen:(mw-1)]*dLL[mlen:(mw-1)])/ris[1, w]\n    ris[7, w] = ris[5, w]/ris[4, w]\n    ris[8, w] = sum(dLV[1, mlen:(mw-1)]*dLL[mlen:(mw-1)])/sum(dLV[1, mlen:(mw-1)])\n    ris[9, w] = sum(dLV[2, mlen:(mw-1)]*dLL[mlen:(mw-1)])/sum(dLV[2, mlen:(mw-1)])\n    ris[10, w] = max((dLV[1, mlen:(mw-1)] > 0)*dLL[mlen:(mw-1)])\n    ris[11, w] = max((dLV[2, mlen:(mw-1)] > 0)*dLL[mlen:(mw-1)])\n    ris[12, w] = 1/ris[11, w]\n    probL = dLV[1, mlen:(mw-1)]/sum(dLV[1, mlen:(mw-1)])\n    probL[probL==0]= 1 #to get rid of zeros in entropy\n    ris[13, w] = -1*sum(probL*log(probL))\n    ris[14, w] = ris[13, w]/log(length(probL))\n    }\n    if (plotG) {\n      def.par =  par(no.readonly = TRUE)\n      layout(matrix(c(1, 2, 3, 4), 2, 2), c(1, 1), c(1, 1), respect=FALSE)\n      par(mar=c(3,4,1,1))\n      plot(c(1:RepMW), ris[1, ], type=\"l\", xlab=\"\", ylab=\"RR\")\n      abline(h=mean(ris[1,]), lty=3)\n      par(mar=c(4,4,0,1))\n      plot(c(1:RepMW), ris[5, ], type=\"l\", xlab=\"\", ylab=\"DET\")\n      abline(h=mean(ris[5,]), lty=3)\n      mtext(\"moving window\", side=1, line=2)\n      par(mar=c(3,4,1,1))\n      plot(c(1:RepMW), ris[6, ], type=\"l\", xlab=\"\", ylab=\"LAM\")\n      abline(h=mean(ris[6,]), lty=3)\n      par(mar=c(4,4,0,1))\n      plot(c(1:RepMW), ris[9, ], type=\"l\", xlab=\"\", ylab=\"TT\")\n      abline(h=mean(ris[9,]), lty=3)\n      mtext(\"moving window\", side=1, line=2)\n      mtext(paste(\"Moving window dimension of\", mw, \"with step of\", step), side=1, line=3, cex=0.8, font=2)\n      par(def.par)\n    }\n    return(ris)\n  }\n",
    "created" : 1371410892635.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2454039718",
    "id" : "A8BC9C72",
    "lastKnownWriteTime" : 1347368748,
    "path" : "~/GitHub/RPqa/RPqa/R/RPqamw.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}